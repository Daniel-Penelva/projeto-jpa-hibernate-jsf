Link do Projeto:
http://localhost:8080/projeto-jpa-hibernate-jsf/index.jsf
http://localhost:8080/projeto-jpa-hibernate-jsf/primeirapagina.jsf

JSF é um MVC (MODEL-VIEW-CONTROLLER)



                             CONTROLLER            VIEW                                MODEL
                          
 CLIENTES -------------->  (Manager Beans)  +  (Páginas JSF) --------------> (entidades e regras de negócio)
          <-------------   (Faces Servlet)       (XHTML)     <-------------

O Controller intercepta os dados da tela que é jogado no Model. Ele também buscas os dados que estão no Model que é jogado para a View (tela).


Principais Componentes do JSF - SITE: https://www.tutorialspoint.com/jsf/index.htm

ShowCase Primefaces - SITE: https://www.primefaces.org/showcase/index.xhtml?jfwid=1aeba

Site oficial javaserverfaces - SITE: https://javaee.github.io/javaserverfaces-spec/

Bibliotecas de terceiros que trabalham com JSF - SITE: http://icefaces-showcase.icesoft.org/showcase.jsf
                                                 SITE: http://showcase.richfaces.org/


< Aula 24.11 - Ensina a configurar o ambiente e a criar o primeiro projeto jsf >
< Aula 24.17 - Ensina a corrigir erros de biblioteca e de java compiler (em relação ao jdk) >

O projeto Maven criado talvez não apareça para o servidor tomcat, o que signfica que o seu projeto não é um projeto web. Logo,temos que 
tornar esse projeto como web. E como fazer isso?

Clica no projeto e com o botão direito do mouse > properties > Projects Facets > Clica em "Convert to faceted form..." > Habilitar 'Dynamic Web Module', 'Javascript, 'JavaServer Faces' e 'JPA' > apply
Clica no projeto e com o botão direito do mouse > properties > Projects Facets > na aba 'Runtimes' define o tomcat que vai ser utilizado > apply
OBS. Se aparecer um "x em vermelho" clica nesse x e em 'JPA implemention' escolhe o type 'Disable Library Configuration' > next > marca o 'Generate web.xml deployment descriptor' > next > ok

OBS. No eclipse a aba 'Markers' foi mostrado erro de java compiler, ou seja, era um erro de jdk que não estava compativel com o projeto. No caso, alterei 
para o JDK que estou usando nos projetos.

------------------------------------------------------------------------

Entendendo o ManagedBean JSF

    Front-end            ------------->  Back-end
   (Página JSF - XHTML)  <-------------  (ManagedBean - Controlador)
   

O JSF terá a página de view (tela) que vai ser criada com um conjunto de tags especiais que vai ser comunicar com o servlet.
 
Vai ser preciso criar os managedbean que é um objeto controlado pelo JSF que por conseqüência vai saber como se comunicar 
com o Servlet e com as tags especiais vinda da tela, ou seja, o managedbean ao ser criado vai ser o responsável por controlar
a página. Lembrando que ele vai ser o back-end  que são os eventos da página (por exemplo, um evento de cadastro). 
Portanto, primeiro lá no Servlet vai ter a anotação “@Controller” onde vai ser possível fazer a instância do objeto que vai
cumprir com o papel de intermediador do managedbean e com o framework Spring.

Vale ressaltar, que a primeiro momento ele vai trabahar com o JSF, logo ele usará a anotação “@ManagedBean” para 
capturar os dados da tela no momento que o usuário executar o botão, esses dados referente ao usuário vão ser capturados 
pelo servlet e vai passar para o seu “@ManagedBean”, logo todos os dados que estavam na tela vão ser armazenados num objeto
da entidade (camada model), onde vai ser setado por ele todos os dados. 

OBS. No arquivo web.xml na pasta WEB-INF, a tag servlet-class é onde está a classe principal do funcionamento do JSF.
OBS. E a tag url-pattern é onde define os mapeamentos da url(s).

Ao criar a página XHTML vai ser preciso adicionar a anotação do JSF na página. E vai ser usado como referencia a letra h 
para o namespace. EX: xmlns:h="http://java.sun.com/jsf/html". 
Esse xml namespace vai ser puxado do próprio framework onde estão as bibliotecas (dependencias) baixadas no Maven do seu projeto.

Link do Projeto:
http://localhost:8080/projeto-jpa-hibernate-jsf/
http://localhost:8080/projeto-jpa-hibernate-jsf/index.jsf

----------------------------------------------

Escopos do Maneged Beans

Quando referenciamos um maneged bean via EL, o framework do JSF instanciará um objeto de classe do manede bean, o 
recuperará uma instância existente. Todas as instâncias possuem um tempo de vida, que é definido dependendo do escopo
usado no maneged bean.

Os escopos de maneged beans JSF podem ser definidos através de anotações do pacote javax.faces.bean.

Objetivo: Define comportamentos para telas e sistemas e cada escopo resolve um tipo de problema e cada um tem sua 
função específica.

-----------------------------------------------

Principais Escopos:

@NoneScoped
O bean será instanciado a cada vez que for referenciado.

@RequestScope (padrão)
Tem vida curta, começando quando é referenciado em uma única requisição HTTP e terminando quando a resposta é 
enviada de volta ao cliente.

@ViewScope 
A instância permanece ativa até que o usário navegue para uma próxima página.

@SessionScoped
Mantém a instância durante diversas requisições e até mesmo navegações entre páginas, até que a sessão do 
usuário seja invalidada ou o tempo limite é atingido. Cada usuário possui uma sessão de navegação, portanto, os 
objetos não são compartilhados entre os usuários.

@ApplicationScoped
Mantém a instância durante todo o tempo de execução da aplicação. É um escopo que compartilha os objetos para 
todos os usuários do sistema.

---------------------------------

Bom saber sobre Request Scoped: 
Em relação ao Request Scoped, ao clicar no botão 'adicionar nome', ele chama uma requisição, no caso, o método 
addNome e adiciona o nome na lista e quando o servidor dá a resposta para o navegador o bean Pessoa (pessoaBean) 
que estava na memória morre (portanto, ao gerar uma requisição ele processo o maneged bean, devolve a resposta, e morre), 
ou seja, tudo que estiver dentro dele vai morrer também, no caso, o usuário adicionado a lista. Por esse motivo que
não é possível usar o request Scoped numa lista já que sempre que for adicionado um usuário ele morre e não vai ser 
possível adicionar outro usuário. Portanto, o Request Scoped só é recomendado usar num cadastro, ou seja, capturou
os dados da tela de cadastro, salvou no banco de dados e por fim morreu.

---------------------------------

Bom saber sobre View Scoped: 
Enquanto estiver com a tela 'primeirapagina.xhtml' aberta, independente do que estiver na tela (exemplo um formulario de cadastro)
o maneged bean vai manter esse estado de ativo, ou seja, vai continuar mantendo os dados na tela. Portanto, o que 
vai fazendo na tela vai guardando os dados.
Logo, ele só morre, se por exemplo, redirecionar a tela para outra página.

---------------------------------

Bom saber sobre Session Scoped: 
Usado para usuários logados. A sessão é mantida enquanto o navegador continuar aberto pelo usuário.
Acesse o link do seu projeto cadastre alguns nomes e depois submeta esse mesmo link em outra aba do seu navegador, 
você verá que manterá os nomes ainda cadastrados.

---------------------------------

Bom saber sobre Application Scoped: 
Significa que todos os usuário irão poder compartilhar esses dados, até os que não teriam permissão de visualizar a 
informação dos dados. É compartilhado em todas as aplicações.

---------------------------------

Managed Bean: É qualquer bean cuja vida é gerenciada pelo Faces.

Backing Bean: Como diz o nome, é um “Bean por detrás”, um “Bean que dá suporte”. Ou seja, é o Bean que está por trás da funcionalidade
de uma página, cuidando dos seus componentes, do estado da página, da navegação, etc. Costuma ser intimamente associado a 
alguma página.
Todo backing-bean também é um managed bean, mas nem todo managed bean é um backing-bean. Pode ser um objeto de negócio, por exemplo.

Backing Bean (são maneged bean) trabalha com os componentes jsf junto com o objeto, ou seja, todos os componentes xhtml 
que estiver terá a respectiva classe do java. É possivel trabalhar com os componentes no back-end. Mas essa pratica não 
é recomendada.

------------------------------

A navegação explicita é feito dentro do arquivo faces-config.xml

------------------------------

Vamos criar um JPUtil para instanciar e criar um EntityManager sempre que precisar se comunicar com o BD. Vamos 
criar um padrão Singleton para instanciar uma única vez.

------------------------------

xmlns:f="http://java.sun.com/jsf/core"

O core da suporte para vários elementos html do jsf

-------------------------------

PainelGrid é um painel que se torna uma tabela para montar formulários e organizar os componentes em tela.

-------------------------------

Sobre o selectOneMenu = comboBox - para selecionar APENAS UMA OPÇÃO
 -> selectItem = adiciona itens 
 -> itemValue = é o valor que vai ser gravado no banco de dados
 -> itemLabel = é o valor que irá aparecer na tela.
 -> required="true"(define como um valor obrigatório - caso não seja marcado não irá salvar no BD)
 -> noSelectionOption = não seleciona o item, ou seja, vai ter que escolher Masculino ou Feminino. 
 
 -------------------------------

Sobre o selectManyMenu = comboBox - para selecionar MAIS DE UMA OPÇÃO

Vale ressaltar que como são vários itens que podem ser marcados, logo o atributo tem que ser do tipo lista.

-------------------------------

Filtro de autenticação (Padrão Open Session)

  (Open session View - abre uma sessão de conexão)
                       |
  (TELA login)         |       
    NAVEGADOR ---------|-------> SERVIDOR
              <--------|--------    
                       |                       
                      FILTER    
             (Intercepta a requisição)
             
Vai ser criado uma classe que vai controlar todas as páginas acessadas. Para poder verificar se o usuário está 
logado ou não. Se não estiver logado vai fazer um redirecionamento para a tela de login.
Vai ser criado a classe 'FilterAutenticacao' e vamos usar a seguinte anotação:

@WebFilter(urlPatterns = {"/*"})
Class FilterAutenticacao implements Filter{...}

OBS. Vai interceptar todas as páginas, ou seja, todas as urls.
OBS. Vai ser implementado o Filter do pacote servlet.

----------------------------------------------------

O atributo 'rendered' permite ocultar ou mostrar componentes ou parte da tela de acordo com o perfil do usuário.
Para fazer esse tipo de funcionalidade vai ser criado um método do tipo boolean e vai receber como 
parametro o tipo de acesso que vai ser permitido. Vai ser recuperado o usuario logado na sessão.

-----------------------------------------------------

BOTÃO EDITAR
No tutorial “PRIMEFACES: DADOS COM DATATABLE”, criamos com o componente p:dataTable, uma tabela para listar os dados cadastrados. 
Dentro do dataTable definimos a estrutura de colunas.

Em termos de linhas de código a estrutura de um p:column é simples, incluindo um atributo que define o cabeçalho, da coluna, 
headerText. E neste caso, como queremos implementar apenas um botão, poderemos recorrer ao JavaServer Faces. Caso, se tratasse 
de uma implementação sofisticada, e, onde o design fizesse a diferença, certamente o PrimeFaces seria a nossa escolha.

Assim, dentro do contexto do dataTable utilizaremos o h:commandLink, componente do JSF que renderiza um elemento HTML – HyperText 
Markup Language (Linguagem de Marcação de Hipertexto), do tipo âncora.

Com o componente f:setPropertyActionListener colocaremos o objeto em edição na tela. Esta tag ficará “escutando” o componente 
que do seu lado, tem como valor uma propriedade bean definida.

E ainda, o f:setPropertyActionListener implementará o value, o responsável por pegar o objeto selecionado pelo usuário, ao 
passo que o target é o objeto do ManagedBean que receberá o objeto pessoa a ser colocado em edição.

BOTÃO EXCLUIR
Os princípios aplicados no botão “Editar” são os mesmos que aplicaremos no botão de “Excluir”, obviamente mudando apenas a 
função do link. Neste caso o “Excluir” deverá chamar o método remover(). Assim, no h:commandLink o atributo action, deverá 
invocar o método.

EM POUCAS PALAVRAS
Desse modo, quando o usuário clicar em “Excluir”, tal como acontece quando o objeto é colocado em edição, o objeto em questão 
é passado para o ManagedBean, que controla a página. E só então o método remover() será chamado.

--------------------------------------------------

Os atributos locale e timeZone Vão fazer com que pegue a data real:
<f:convertDateTime pattern="dd/MM/yyyy" locale="pt_BR" timeZone="GMT-03:00"/>

OBS. converterMessage="Data Errada"
É um validador de data para caso do usuário entrar com a data errada.

---------------------------------------------------

Consulta CEP (Web Service CEP - link: https://viacep.com.br/ ou https://viacep.com.br/ws/01001000/json/)

Com o JSF é diferente do JSP que usava um JQuery que retornava esse json e preenchia na tela.

Passos com o JSF:
1 - Preencher na tela com o JSF

2 - Fazer um evento de perda de foco (quando é carregado para vc automaticamente os dados do CEP. No caso, é um  
                                      método executado que carrega o CEP e que fica do lado do manegead bean)
                                      
3 - Mandar para o lado do back-end no manegead bean

4 - Interceptar

5 - Fazer a requisição pelo web service

6 - Setar para os atributos do managead bean do objeto q o managead bean controla 

7 - Mandar para a tela

Parte 1
Primeiro vamos colocar um campo de CEP na tela e fazer a ativaçao na hora que se perde o foco ao digitar o cep que
vai ser executado um método de pesquisa de cep do lado do manegead bean, enviando o cep que foi digitado pelo usuário.

<f:ajax event="blur" execute="@this" render="" listener="#{pessoaBean.pesquisaCep}"/>

Propriedades:

 -> event = é um evento de uma ação (clique de botão, entrada de foco ou mudança de valor etc). No caso, a perda de foco
 no JSF é blur. Na perda de foco vai ser executado o ajax.
 
 -> execute = Executa o componente InputText, ou seja, o @this seria o próprio componente que vai enviar os dados para o lado 
 do managead bean.
 
 -> render = Depois de consultar para o lado do managead bean, ou seja, depois de consultar o cep, irá setar os dados pelo objeto que 
 vai mostrar os campos em tela carregados do CEP. Ou seja, recarregar o objeto na tela.
 
 -> listener = é o método que vai ser executado que vai consultar o cep. O listener vai ser executado depois de perder o foco.

------------------------------------------------
Para deslogar o usuário basta acessar o mesmo getSessionMap e fazer um remove, depois fazer um invalidate da sessão.

------------------------------------------------

Nessa parte 4 do combo dependentes, analisando: Na hora de selecionar o valor do Estado do combo, vai ser disparado um evento 
pelo lado do servidor que vai ser recuperado o valor (o código do Estado) do Estado. Vai ser feito isso através do ajax que vai
acionar esse evento de mudança ao lado do servidor e do managead bean, que vai capturar essa seleção de item (@This) e enviado 
ao lado do servidor. Essa execução vai ser executada por um método através do 'listener'. Vamos capturar o valor através do
objeto todo, logo, vai ser criado um 'var' e capturar esse objeto todo através do 'itemValue'.
A propriedade 'immediate' é para deixar passar a fase de validação, ou seja, se tiver alguma fase de validação no formulário 
o ajax não irá conseguir fazer funcionar por debaixo dos pano, portanto, sempre que for usar o ajax, usa-se o immediate.

Vale ressaltar que o primeiro valor que está no combo é o 'Acre', e não podemos deixar esse valor como primeira opção, pois até
o momento ainda não existe uma ação feito pelo o usuário para definir o valor, logo para resolver esse problema vamos adicionar 
a tag 'selectItem' e a propriedade 'itemLabel' para definir um valor definido na tela. Vale ressaltar que não podemos deixar 
esse valor para que o usuário não selecione e que não salve no BD (não deixar disparar um evento), para isso vamos utilizar 
a propriedade 'noSelectionOption'.
